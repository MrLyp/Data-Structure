## 💬 [动态规划法](#welcome)

&emsp;&emsp;不会很多废话，希望大家坚持，以及，跟上节奏。

<div align="right">
    <a href="../README.md#-目录">返回目录 ↩</a>
</div>

&emsp;&emsp;**"动态规划法的基本思想是将待求解问题分解成若干子问题，先求解子问题，再结合这些子问题得解得到原问题的解。<br>与分治法不同的是，适合用动态规划法求解的问题经分解得到的子问题往往不是互相独立的"**

&emsp;&emsp;**动态规划算法适合于解最优化问题，通常可按以下 4 个步骤设计：① 找出最优解的性质，并刻画其结构特征；② 递归地定义最优值；③ 以自底向上的方式计算最优值；④ 根据计算最优值时得到的信息，构造最优解。**

### 💡 矩阵连乘问题

+ 给定 n 个矩阵 {A<sub>1</sub>,A<sub>2</sub>,...,A<sub>n</sub>}，其中 A<sub>i</sub> 与 A<sub>i+1</sub> 是可乘的，i=1，2，...，n-1。如何确定计算矩阵连乘积的计算次序，使得依次次序计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。

+ 例如：给定三个连乘矩阵 {A<sub>1</sub>,A<sub>2</sub>,A<sub>3</sub>} 的维数分别是 10\*100，100\*5 和 5\*50，采用 (A<sub>1</sub>A<sub>2</sub>)A<sub>3</sub>，乘法次数为 10\*100\*5+10\*5\*50=7500 次，而采用 A<sub>1</sub>(A<sub>2</sub>A<sub>3</sub>)，乘法次数为 100\*5\*50+10\*100\*50=75000 次乘法，显然，最好的次序是 (A<sub>1</sub>A<sub>2</sub>)A<sub>3</sub>，乘法次数为 7500 次。

+ Python 语言实现：

    ```python
    def matrix_chain(p, n, m, s):
        for i in range(n):
            m[i][i] = 0
        for r in range(2, n+1):
            for i in range(1, n-r+2):
                j = i + r -1
                m[i][j] = m[i+1][j] + p[i-1]*p[i]*p[j]
                s[i][j] = i
                for k in range(i+1, j):
                    t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j]
                    if t < m[i][j]:
                        m[i][j] = t
                        s[i][j] = k

    def print_result(s, i, j):
        if i == j:
            print('A{}'.format(i), end="")
        else:
            print('(', end="")
            print_result(s, i, s[i][j])
            print_result(s, s[i][j]+1, j)
            print(')', end="")


    n = 6
    p = [30, 35, 15, 5, 10, 20, 25]
    m = [[0 for i in range(n+1)] for i in range(n+1)]
    s = [[0 for i in range(n+1)] for i in range(n+1)]

    matrix_chain(p, n, m, s)
    print_result(s, 1, n-1)
    print()
    ```

+ C 语言实现：

    ```c
    #include <stdio.h>

    const int n = 6;

    /*
    * 自底向上方式
    * 
    */
    void MatrixChain(int *p, int n, int m[n][n], int s[n][n])
    {
        for(int i=0; i < n; i++)
            m[i][i] = 0;
        for(int r=2; r<=n; r++)
            for(int i=1; i<= n-r+1; i++)
            {
                int j = i+r-1;
                m[i][j] = m[i+1][j] + p[i-1]*p[i]*p[j];
                s[i][j] = i;
                for(int k=i+1; k<j; k++)
                {
                    int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];
                    if(t<m[i][j])
                    {
                        m[i][j] = t;
                        s[i][j] = k;
                    }
                }
            }
    }

    void Print(int s[n][n], int i, int j)
    {
        if(i == j)
            printf("A%d", i);
        else
        {
            printf("(");
            Print(s, i, s[i][j]);
            Print(s, s[i][j]+1, j);
            printf(")");
        }
    }

    int main()
    {
        int p[7] = {30, 35, 15, 5, 10, 20, 25};
        int m[n+1][n+1], s[n+1][n+1];
        MatrixChain(p, n, m, s);
        Print(s, 1, n-1);
        printf("\n");

        return 0;
    }
    ```

### 💡 最大子段和问题

### 💡 0-1 背包问题

### 💡 最长公共子序列（LCS）问题

<br>
<div align="right">
    <a href="#-动态规划法">返回顶部 ⤴</a>
</div>