<a name="top"></a>
<div align="left">
    <a href="/README.md"><b>↩返回主页</b></a>
</div>
<div align="right">
    <b>
    <a href="1.1.1%20基本概念和术语.md">⬅上一节 </a>
    /
    <a href="../1.2%20算法和算法评价/1.2.1%20.md"> 下一节➡</a>
    </b>
</div>
<hr>

## 1.1.2 数据结构三要素

<br>

&emsp;&emsp;从上一节也能了解到，好的算法必须要求高效率与低存储量需求，所以我们在 **时间复杂度** 和 **空间复杂度** 对算法的效率作度量。

<br>

+ **时间复杂度**

    + 让算法先运行，事后统计运行时间？不可！存在的问题如下：

        + 算法和机器性能有关，如：超级计算机 v.s. 单片机

        + 算法和编程语言有关，越高级的语言执行效率越低

        + 算法和编译程序产生的机器指令质量有关

        + 有些算法是不能事后再统计的，如：导弹控制算法

        **结论：** 在评价一个算法时间开销的优劣时，排除与算法本身无关的外界因素，且不能用事后再评判。

    + 算法时间复杂度：事前预估算法时间开销 T(n) 与问题规模 n 的关系（T 表示 time）

    + 例子——循环案例：

        ```c
        // 算法一：逐步递增型爱你
        // n 为问题的规模
        void loveYou(int n) {
            int i = 1;                              // ① 爱你的程度
            while(i <= n) {                         // ②
                i++;                                // ③ 每次 +1
                printf("I Love You %d\n", i);       // ④
            }
            printf("I Love You More Than %d\n", n); // ⑤
        }

        int main() {
            loveYou(3000);
        }
        ```

        + 语句频度：

            ```
            ①    --  1次
            ②    --  3001次
            ③④   --  3000次
            ⑤    --  1次

            T(3000) = 1 + 3001 + 2*3000 + 1
            ```

            时间开销与问题规模 n 的关系为：T(n) = 3n + 3

    + 当 n 足够大时，我们只需要考虑阶数最高的项即可

    + 大 O 表示法：大 O 表示“同阶”、同等数量级。如 T<sub>1</sub>(n) = O(n)、T<sub>2</sub>(n) = O(n<sup>2</sup>)、T<sub>3</sub>(n) = O(n<sup>3</sup>)

        + 加法规则：多项相加，只保留最高阶的项，且系数变为 1

            T(n) = T<sub>1</sub>(n) + T<sub>2</sub>(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(m)))

        + 乘法规则：多项相乘，都保留

            T(n) = T<sub>1</sub>(n) × T<sub>2</sub>(n) = O(f(n)) × O(g(n)) = O(f(n) × g(m))

            eg: T<sub>3</sub>(n) = n<sup>3</sup> + n<sup>2</sup>log<sub>2</sub>n = O(n<sup>3</sup>) + O(n<sup>2</sup>log<sub>2</sub>n) = O(n<sup>3</sup>)

        + O(1) < O(log<sub>2</sub>n) < O(n) < O(nlog<sub>2</sub>n) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>) < O(n!) < O(n<sup>n</sup>)

    + 根据大 O 表示法，上述算法例子 T(n) = 3n + 3 = O(n)

+ **空间复杂度**

<br>

## 💡 题型

&emsp;&emsp;xxx

### 单项选择题

1. xxxx（ ）

    A. xxx<br>
    B. XX<br>
    C. Xx<br>
    D. xX<br><br>
    <details>
    <summary>查看解析</summary>
    <p>答案：x</p>
    </details>

<hr>

<div align="right">
    <a href="#top">返回顶部⤴</a>
</div>

<div align="center">
    <b>-- 完 --</b>
</div>