<a name="top"></a>
<div align="left">
    <a href="/README.md"><b>↩返回主页</b></a>
</div>
<div align="right">
    <b>
    <a href="../3.2%20队列/3.2.4%20双端队列.md">⬅上一节 </a>
    /
    <a href="3.3.2%20栈在表达式求值中的应用.md"> 下一节➡</a>
    </b>
</div>
<hr>

## 3.3.1 栈在括号匹配中的应用

<br>

&emsp;&emsp;在数学上，我们经常能遇到有关表达式的出现。在一个表达式中，为了表示运算符的运算优先级，常常会引入小括号 `()` 和中括号 `[]` 用以辅助。

&emsp;&emsp;如表达式：`[(A + B) * C] - [E - F]`，我们可以将其中的小括号和中括号提取出来：`[ () ] [ ]`。我们称这样的序列为 **括号匹配序列**。

+ 匹配序列

    `( [ ( ) ] )` &emsp; `[ ] [ ] ( )` &emsp; `( ) [ ( ) ]`

+ 不匹配序列

    `( [ ( ) ]` &emsp; `] [ ] ( )` &emsp; `( ] [ ( ) ]`

<br>

```
1  2  3  4  5  6
[  (  )  ]  [  ]
```

**算法思想：**

1. 初始化一个空栈，顺序读入括号。

1. 若是右括号，则与栈顶元素进行匹配

    + 若匹配，则弹出栈顶元素并进行下一个元素

    + 若不匹配，则该序列不合法

1. 若是左括号，则压入栈中

1. 若全部元素遍历完毕，栈中非空，则序列不合法

<br>

+ C 语言算法

    > 源文件地址，[/codes/3/栈——括号匹配验证.c](/codes/3/栈——括号匹配验证.c)

    ```c

    ```

+ Python 算法

    > 源文件地址，[/codes/3/栈——括号匹配验证.py](/codes/3/栈——括号匹配验证.c)

    ```python

    ```

<br>

## 💡 题型

&emsp;&emsp;xxx

### 单项选择题

1. xxxx（ ）

    A. xxx<br>
    B. XX<br>
    C. Xx<br>
    D. xX<br><br>
    <details>
    <summary>查看解析</summary>
    <p>答案：x</p>
    </details>

<hr>

<div align="right">
    <a href="#top">返回顶部⤴</a>
</div>

<div align="center">
    <b>-- 完 --</b>
</div>